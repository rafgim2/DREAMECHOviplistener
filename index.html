<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>DreamEcho - Oyente VIP</title>

  <!-- 1) Tone.js (para s√≠ntesis virtual si usas modo ‚Äúvirtual‚Äù) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.39/Tone.min.js"></script>

  <!-- 2) MidiWriter.js (Browser build 3.1.1) -->
  <script src="https://cdn.jsdelivr.net/npm/midi-writer-js@3.1.1/browser/midiwriter.min.js"></script>

  <style>
    body {
      font-family: sans-serif;
      padding: 1em;
      text-align: center;
    }
    h1 {
      font-size: 3em;
      margin-bottom: 0.2em;
    }
    #recuentoOyentes {
      font-size: 1.2em;
      margin-bottom: 0.5em;
      color: #555;
    }
    button {
      margin: 0.5em;
      font-size: 2em;
      padding: 1em 2em;
      cursor: pointer;
    }
    #status {
      margin-bottom: 1em;
      font-size: 1.2em;
    }
    #midiSelectContainer {
      margin-top: 1em;
    }
    #grabacionControles {
      margin-top: 2em;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5em;
    }
    #grabacionesSelect {
      font-size: 1em;
      padding: 0.5em;
      margin: 0.5em;
    }
    button.grabando {
      animation: parpadeo 1s infinite;
      background-color: red;
      color: white;
    }
    @keyframes parpadeo {
      0% { opacity: 1; }
      50% { opacity: 0.3; }
      100% { opacity: 1; }
    }
    /* Chat */
    #chatLog {
      width: 90%;
      max-width: 600px;
      height: 200px;
      margin: 1em auto 0.5em;
      padding: 0.5em;
      border: 1px solid #ccc;
      overflow-y: auto;
      text-align: left;
      background: #fafafa;
      border-radius: 0.5em;
    }
    #chatInput {
      width: 70%;
      max-width: 500px;
      padding: 0.5em;
      font-size: 1em;
    }
    #sendChatBtn {
      padding: 0.6em 1em;
      font-size: 1em;
      cursor: pointer;
      margin-left: 0.5em;
    }
    /* Clase para destacar el mensaje del oyente actual */
    .mensaje-propio {
      color: blue;
    }
    /* Contenedor para el enlace de descarga manual */
    #descargaLink {
      margin-top: 1em;
      font-size: 1em;
    }
    #descargaLink a {
      color: #0066cc;
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <h1>DreamEcho - Oyente VIP</h1>
  <p id="recuentoOyentes">Oyentes conectados: --</p>
  <p id="status">Esperando conexi√≥n‚Ä¶</p>

  <button onclick="modoMIDI()">üéπ Usar mi piano digital</button>
  <button onclick="modoVirtual()">üéß Escuchar con sonido virtual</button>

  <div id="midiSelectContainer"></div>

  <!-- Chat -->
  <div id="chatControles">
    <div id="chatLog"></div>
    <input id="chatInput" placeholder="Escribe tu mensaje‚Ä¶" />
    <button id="sendChatBtn">üó®Ô∏è Enviar</button>
  </div>

  <!-- Grabaciones y controles -->
  <div id="grabacionControles">
    <button id="btnGrabar" onclick="iniciarGrabacion()">‚è∫Ô∏è Grabar</button>
    <button onclick="detenerGrabacion()">‚èπÔ∏è Detener</button>
    <select id="grabacionesSelect">
      <option value="">-- Elige una grabaci√≥n --</option>
    </select>
    <button onclick="reproducirGrabacion()">‚ñ∂Ô∏è Reproducir</button>
    <button onclick="borrarGrabacion()">üóëÔ∏è Borrar</button>
    <button onclick="renombrarGrabacion()">‚úèÔ∏è Renombrar</button>
    <!-- Bot√≥n que genera y descarga el .mid usando MidiWriter.js -->
    <button onclick="descargarGrabacionComoMID()">üíæ Descargar .mid</button>
    <!-- Si el clic autom√°tico falla, aparecer√° este enlace -->
    <div id="descargaLink"></div>
  </div>

  <script>
    // ======================
    // FUNCIONES AUXILIARES
    // ======================

    // Convierte un n√∫mero MIDI (0‚Äì127) en nombre de nota (p.ej. 60 ‚Üí "C4").
    function midiNumberToNoteName(number) {
      const names = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
      const octave = Math.floor(number / 12) - 1;
      const noteIndex = number % 12;
      return names[noteIndex] + octave;
    }

    // ======================
    // ACCESO AL DOM
    // ======================
    const statusEl        = document.getElementById("status");
    const oyentesEl       = document.getElementById("recuentoOyentes");
    const midiSelectContainer = document.getElementById("midiSelectContainer");
    const grabacionesSelect   = document.getElementById("grabacionesSelect");
    const btnGrabar       = document.getElementById("btnGrabar");
    const chatLog         = document.getElementById("chatLog");
    const chatInput       = document.getElementById("chatInput");
    const sendChatBtn     = document.getElementById("sendChatBtn");
    const descargaLinkDiv = document.getElementById("descargaLink");

    // ======================
    // VARIABLES DE ESTADO
    // ======================
    let output = null, modo = null, synth = null, pedal = false;
    let baseTime = null, queuePos = 0, queueLatency = 100;
    const notasActivas    = new Set();
    const notasSostenidas = new Set();
    let grabando = false;
    let grabacionActual = [];
    let grabaciones = [];
    let primeraEstadisticaMostrada = false;

    // Nombre de usuario para el chat
    const username = prompt("¬øC√≥mo quieres que te vean en el chat?", "Oyente") || "Oyente";

    // ======================
    // WEBSOCKET
    // ======================
    const ws = new WebSocket("wss://dreamecho.onrender.com");

    // ======================
    // CARGA INICIAL DE GRABACIONES
    // ======================
    window.onload = () => {
      const guardadas = localStorage.getItem("dreamEchoGrabaciones");
      if (guardadas) {
        grabaciones = JSON.parse(guardadas);
        actualizarListaGrabaciones();
      }
    };

    function guardarEnLocalStorage() {
      localStorage.setItem("dreamEchoGrabaciones", JSON.stringify(grabaciones));
    }

    function actualizarListaGrabaciones() {
      grabacionesSelect.innerHTML = `<option value="">-- Elige una grabaci√≥n --</option>`;
      grabaciones.forEach((g, i) => {
        const opt = document.createElement("option");
        opt.value = i;
        opt.text = g.nombre || `Grabaci√≥n ${i + 1}`;
        grabacionesSelect.appendChild(opt);
      });
    }

    // ======================
    // FUNCIONES DE GRABACI√ìN
    // ======================
    function iniciarGrabacion() {
      grabando = true;
      grabacionActual = [];
      baseTime = null;
      statusEl.innerText = "Grabando‚Ä¶ toca algo desde el piano.";
      btnGrabar.classList.add("grabando");
      descargaLinkDiv.innerHTML = "";  // Limpiar enlace viejo (por si existe)
      console.log("[grabaci√≥n] Iniciada. grabacionActual vac√≠a.");
    }

    function detenerGrabacion() {
      grabando = false;
      btnGrabar.classList.remove("grabando");
      if (grabacionActual.length) {
        const nueva = {
          nombre: `Grabaci√≥n ${grabaciones.length + 1}`,
          eventos: grabacionActual
        };
        grabaciones.push(nueva);
        guardarEnLocalStorage();
        actualizarListaGrabaciones();
        statusEl.innerText = `${nueva.nombre} guardada.`;
        console.log(`[grabaci√≥n] Detenida. ${grabacionActual.length} eventos almacenados.`);
      } else {
        statusEl.innerText = "Nada grabado.";
        console.log("[grabaci√≥n] Detenida. grabacionActual sigue vac√≠a.");
      }
    }

    function reproducirGrabacion() {
      const idxStr = grabacionesSelect.value;
      if (idxStr === "") return;
      const idx = parseInt(idxStr, 10);
      if (isNaN(idx) || idx < 0 || idx >= grabaciones.length) return;

      const eventos = grabaciones[idx].eventos;
      eventos.forEach(ev => {
        const delay = Math.max(0, ev.time - eventos[0].time);
        setTimeout(() => {
          ws.dispatchEvent(new MessageEvent("message", {
            data: JSON.stringify({ type: "midi", data: ev.data, time: 0 })
          }));
        }, delay);
      });
      statusEl.innerText = `Reproduciendo: ${grabaciones[idx].nombre}`;
      console.log(`[reproducci√≥n] Iniciada "${grabaciones[idx].nombre}" con ${eventos.length} eventos.`);
    }

    function borrarGrabacion() {
      const idxStr = grabacionesSelect.value;
      if (idxStr === "") return;
      const idx = parseInt(idxStr, 10);
      if (isNaN(idx) || idx < 0 || idx >= grabaciones.length) return;

      if (!confirm(`¬øBorrar "${grabaciones[idx].nombre}"?`)) return;

      console.log(`[grabaci√≥n] Borrando √≠ndice ${idx}: "${grabaciones[idx].nombre}".`);
      grabaciones.splice(idx, 1);
      guardarEnLocalStorage();
      actualizarListaGrabaciones();
      statusEl.innerText = "Grabaci√≥n borrada.";
      descargaLinkDiv.innerHTML = "";
    }

    function renombrarGrabacion() {
      const idxStr = grabacionesSelect.value;
      if (idxStr === "") return;
      const idx = parseInt(idxStr, 10);
      if (isNaN(idx) || idx < 0 || idx >= grabaciones.length) return;

      const nuevo = prompt("Nuevo nombre:", grabaciones[idx].nombre);
      if (nuevo) {
        console.log(`[grabaci√≥n] Renombrada √≠ndice ${idx} a "${nuevo}".`);
        grabaciones[idx].nombre = nuevo;
        guardarEnLocalStorage();
        actualizarListaGrabaciones();
        statusEl.innerText = `Grabaci√≥n renombrada a "${nuevo}".`;
      }
    }

    // ======================
    // DESCARGA DEL .mid V√ÅLIDO (Formato 0, canal 1)
    // ======================
    function descargarGrabacionComoMID() {
      console.log("[descarga] Bot√≥n pulsado.");

      const idxStr = grabacionesSelect.value;
      if (idxStr === "") {
        statusEl.innerText = "No hay grabaci√≥n seleccionada.";
        console.warn("[descarga] No hay grabaci√≥n seleccionada (idxStr vac√≠o).");
        return;
      }
      const idx = parseInt(idxStr, 10);
      if (isNaN(idx) || idx < 0 || idx >= grabaciones.length) {
        statusEl.innerText = "√çndice de grabaci√≥n inv√°lido.";
        console.error(`[descarga] √çndice inv√°lido: ${idxStr}`);
        return;
      }

      const eventos = grabaciones[idx].eventos;
      if (!eventos || eventos.length === 0) {
        statusEl.innerText = "No hay eventos en esta grabaci√≥n.";
        console.warn(`[descarga] Grabaci√≥n "${grabaciones[idx].nombre}" sin eventos.`);
        return;
      }

      // Verificar que MidiWriter est√° disponible
      if (typeof MidiWriter === "undefined") {
        console.error("[descarga] MidiWriter no est√° definido. Comprueba que se carg√≥ correctamente.");
        statusEl.innerText = "Error: no se ha cargado MidiWriter.js";
        return;
      }

      // 1) Crear un √∫nico track (Formato 0) con metadatos + notas
      const track = new MidiWriter.Track();

      // 1.a) Tempo 90 BPM (Meta Set Tempo)
      track.setTempo(90);
      // 1.b) Time Signature 4/4 (Meta Time Signature)
      track.addEvent(new MidiWriter.TimeSignatureEvent({
        numerator: 4,
        denominator: 4,
        metronome: 24,
        thirtyseconds: 8
      }));
      // 1.c) Program Change: Piano cl√°sico (instrumento 1) en canal 1
      track.addEvent(new MidiWriter.ProgramChangeEvent({
        instrument: 1,
        channel: 1
      }));

      // 2) Convertir eventos en NoteEvent en el mismo track (canal 1)
      const startTime = eventos[0].time;
      eventos.forEach(ev => {
        const [st, note, vel] = ev.data;
        const command = st & 0xf0;
        // Solo notas ON (0x90 con velocity > 0)
        if (command === 0x90 && vel > 0) {
          const deltaMs = ev.time - startTime;
          const deltaTicks = Math.round(deltaMs / 10);
          track.addEvent(new MidiWriter.NoteEvent({
            pitch: [ midiNumberToNoteName(note) ],
            duration: 'T128',   // 1 negra exacta (128 ticks)
            startTick: deltaTicks,
            velocity: vel / 127,
            channel: 1
          }));
        }
      });

      // 3) Generar Writer en Formato 0 (single track)
      const writer = new MidiWriter.Writer(track);
      const blob = new Blob([writer.buildFile()], { type: 'audio/midi' });
      const url = URL.createObjectURL(blob);

      // 4) Limpiar contenedor de enlace anterior
      descargaLinkDiv.innerHTML = "";

      // 5) Crear un <a> visible (por si el clic autom√°tico falla)
      const aVisible = document.createElement("a");
      const nombreArchivo = (grabaciones[idx].nombre || `grabacion_${idx + 1}`)
        .replace(/\s+/g, "_") + ".mid";
      aVisible.href = url;
      aVisible.download = nombreArchivo;
      aVisible.textContent = "Si no descarga autom√°ticamente, haz clic aqu√≠";
      descargaLinkDiv.appendChild(aVisible);

      // 6) Intentar disparar la descarga autom√°ticamente
      setTimeout(() => {
        aVisible.click();
        console.log(`[descarga] Intento de clic autom√°tico para "${nombreArchivo}".`);
        statusEl.innerText = `Descargando ${nombreArchivo}`;
      }, 100);

      // 7) Revocar la URL pasado un rato para liberar memoria
      setTimeout(() => {
        URL.revokeObjectURL(url);
        console.log(`[descarga] URL revocada para "${nombreArchivo}".`);
      }, 30000);
    }

    // ======================
    // CHAT Y MIDI ENTRANTES
    // ======================
    function appendChat(user, text) {
      const msg = document.createElement("div");
      const time = new Date().toLocaleTimeString();
      if (user === username) {
        msg.classList.add("mensaje-propio");
      }
      msg.innerHTML = `<small>[${time}]</small> <strong>${user}:</strong> ${text}`;
      chatLog.appendChild(msg);
      chatLog.scrollTop = chatLog.scrollHeight;
    }

    function sendChat() {
      const text = chatInput.value.trim();
      if (!text || ws.readyState !== WebSocket.OPEN) return;
      ws.send(JSON.stringify({ type: "chat", user: username, text }));
      chatInput.value = "";
    }

    sendChatBtn.addEventListener("click", sendChat);
    chatInput.addEventListener("keydown", e => {
      if (e.key === "Enter") sendChat();
    });

    ws.onopen = () => {
      statusEl.textContent = "Conectado al servidor, esperando tu elecci√≥n‚Ä¶";
    };

    ws.onmessage = async event => {
      const raw = typeof event.data === "string" ? event.data : await event.data.text();
      const msg = JSON.parse(raw);

      if (msg.type === "stats") {
        oyentesEl.textContent = `Oyentes conectados: ${msg.clients}`;
        if (!primeraEstadisticaMostrada) {
          queuePos = msg.clients;
          queueLatency = 50 + 5 * Math.sqrt(queuePos);
          statusEl.textContent =
            `Posici√≥n en cola: ${queuePos} ‚Üí latencia = ${Math.round(queueLatency)} ms`;
          primeraEstadisticaMostrada = true;
        }
        return;
      }

      if (msg.type === "chat") {
        appendChat(msg.user, msg.text);
        return;
      }

      if (msg.type === "midi") {
        const [st, note, velocity] = msg.data;
        const command = st & 0xf0;
        const eventTime = msg.time;
        if (!baseTime) baseTime = performance.now() - eventTime;

        // ‚Üê‚Üê‚Üê GRABAR CADA EVENTO MIDI QUE LLEGA ‚Üê‚Üê‚Üê
        if (grabando) {
          grabacionActual.push({
            data: msg.data,
            time: eventTime
          });
          console.log(`[grabaci√≥n] Evento push: data=${msg.data}, time=${eventTime}`);
        }
        // ‚Üê‚Üê‚Üê FIN DE GRABAR ‚Üê‚Üê‚Üê

        const extra = modo === "virtual" ? queueLatency : 0;
        const delay = Math.max(
          0,
          eventTime + baseTime - performance.now() + extra
        );
        const toneTime = "+" + (delay / 1000);

        if (modo === "midi" && output) {
          return setTimeout(() =>
            output.send(new Uint8Array(msg.data)), delay
          );
        }

        if (modo === "virtual" && synth) {
          const freq = Tone.Frequency(note, "midi").toFrequency();
          if (command === 0x90 && velocity > 0) {
            synth.triggerAttack(freq, undefined, velocity / 127);
            notasActivas.add(freq);
            notasSostenidas.delete(freq);
          } else if (command === 0x80 || (command === 0x90 && velocity === 0)) {
            if (pedal) {
              notasActivas.delete(freq);
              notasSostenidas.add(freq);
            } else {
              synth.triggerRelease(freq, "+0.2");
              notasActivas.delete(freq);
              notasSostenidas.delete(freq);
            }
          } else if (st === 176 && note === 64) {
            pedal = velocity >= 64;
            if (!pedal) {
              notasSostenidas.forEach(f => {
                if (!notasActivas.has(f)) {
                  synth.triggerRelease(f, "+0.2");
                  notasSostenidas.delete(f);
                }
              });
            }
          }
        }
      }
    };

    // ======================
    // MODO MIDI Y VIRTUAL
    // ======================
    function modoMIDI() {
      modo = "midi";
      statusEl.innerText = "Buscando dispositivos MIDI de salida‚Ä¶";
      navigator.requestMIDIAccess().then(midiAccess => {
        const outputs = Array.from(midiAccess.outputs.values());
        if (outputs.length) {
          midiSelectContainer.innerHTML = "";
          const sel = document.createElement("select");
          sel.id = "midiOutSelect";
          const dopt = document.createElement("option");
          dopt.text = "-- Elige dispositivo MIDI --";
          dopt.value = "";
          sel.appendChild(dopt);
          outputs.forEach((o, i) => {
            const opt = document.createElement("option");
            opt.value = o.id;
            opt.text = o.name || `MIDI Dispositivo ${i + 1}`;
            sel.appendChild(opt);
          });
          sel.addEventListener("change", e => {
            const chosen = outputs.find(o => o.id === e.target.value);
            if (chosen) {
              output = chosen;
              statusEl.innerText = `Salida MIDI seleccionada: ${chosen.name}`;
            } else {
              statusEl.innerText = "No se ha seleccionado salida MIDI.";
              output = null;
            }
          });
          midiSelectContainer.appendChild(sel);
          statusEl.innerText = "Selecciona un dispositivo MIDI para usarlo.";
        } else {
          statusEl.innerText = "No se han encontrado salidas MIDI.";
        }
      }).catch(() => {
        statusEl.innerText = "No se ha podido acceder a WebMIDI.";
      });
    }

    async function modoVirtual() {
      modo = "virtual";
      statusEl.innerText = "Cargando piano virtual‚Ä¶";
      await Tone.start();
      synth = new Tone.Sampler({
        urls: {
          A0:  "A0.mp3", C1:  "C1.mp3", "D#1":"Ds1.mp3","F#1":"Fs1.mp3",
          A1:  "A1.mp3", C2:  "C2.mp3","D#2":"Ds2.mp3","F#2":"Fs2.mp3",
          A2:  "A2.mp3", C3:  "C3.mp3","D#3":"Ds3.mp3","F#3":"Fs3.mp3",
          A3:  "A3.mp3", C4:  "C4.mp3","D#4":"Ds4.mp3","F#4":"Fs4.mp3",
          A4:  "A4.mp3", C5:  "C5.mp3","D#5":"Ds5.mp3","F#5":"Fs5.mp3",
          A5:  "A5.mp3", C6:  "C6.mp3","D#6":"Ds6.mp3","F#6":"Fs6.mp3",
          A7:  "A7.mp3", C8:  "C8.mp3"
        },
        baseUrl: "https://tonejs.github.io/audio/salamander/",
        release: 0.4,
        onload: () => {
          statusEl.innerText =
            `Modo virtual listo. Posici√≥n en cola: ${queuePos} ‚Üí latencia ‚âÉ ${Math.round(queueLatency)} ms`;
        }
      }).toDestination();
    }
  </script>
</body>
</html>
